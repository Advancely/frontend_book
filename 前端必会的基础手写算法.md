##### 深克隆

- 方法一

```shell
function deepClone(obj){
	if(obj === null){return null}
  if(typeof obj !== 'object'){return obj}
  if(obj instanceof RegExp){return new RegExp(obj)}
  if(obj instanceof Date){return new Date(obj)}
  //let cloneObj = new obj.constructor
  let cloneObj = new Object()
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      cloneObj[key] = deepClone(obj[key])
    }
  }
  return cloneObj
}
```

- 方法二

```shell
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

JSON.parse(JSON.stringify(obj))
```

`JSON.parse`这种方式弊端:正则、函数、日期、symbol等,会有问题 

##### 浅克隆

```shell
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};


let obj1 = {...obj}

let obj2 = {}
for(let key in obj){
  if(obj.hasOwnProperty(key)){
    obj2[key] = obj[key]
  }
}
```

##### a==1&&a==2&&a==3

- toString

```shell
let a = {
	i:0,
  toString:function(){
    return ++this.i;
  }
}
console.log(a==1&&a==2&&a==3)
```

- toString&shift

```shell
var a = [1,2,3]
a.toString = a.shift
console.log(a==1&&a==2&&a==3)
```

- 利用数据劫持get

```shell
var i = 0;
Object.defineProperty(window,'a',{
  set(){
    
  },
  get(){
    return ++i
  }
})
console.log(a==1&&a==2&&a==3)
```

##### 数组去重

- Set

```shell
let ary = [12, 23, 12, 15, 25, 23, 25, 14, 16];

Array.from(new Set(ary))

[...new Set(ary)]
```

- 遍历去重（后面所有数组成一个数组）

```shell
function fn(ary){
  for(let i =0;i<ary.length-1;i++){
    let item = ary[i]
    let args = ary.slice(i+1)
    if(args.indexOf(item)>-1){
      ary.splice(i,1)
      i--;
    }
  }
  return ary
}
```

```shell
function fn(ary){
  for(let i = 0;i<ary.length-1;i++){
    let item = ary[i],
    		args = ary.slice(i+1)
    if(argsindexOf(item)>-1){
      ary[i] = null;
    }
  }
  ary.filter(item=>item!==null)
  return ary;
}
```

- 新容器

```shell
function fn(ary){
  let arr = [ary[0]]
  for(let i = 1;i<ary.length;i++){
    if(!(arr.indexOf(ary[i])>-1)){
      arr.push(ary[i])
    }
  }
  return arr;
}
```

- 先排序再去重

```shell
function fn(ary){
  ary = ary.sort((a,b)=>a-b)
  for(let i = 0;i < ary.length;i++){
    if(ary[i] === ary[i+1]){
      ary.splice(i,i)
      i--;
    }
  }
  return ary;
}
```

##### 排序算法

- 冒泡排序

```shell
function fn(arr){
  for(let i =0;i < arr.length -1;i++){			//控制次数，记得计算0为第一次
    for(let j = 0;j < arr.length -i -1;j++){		//取到倒数第二项为止
      arr[j+1]>arr[j]?[arr[j+1],arr[j]]=[arr[j],arr[j+1]]:null
    }
  }
  return arr;
}
```

- 插入排序

```shell
let ary = [12, 23, 12, 15, 25, 23, 25, 14, 16];

function fn(arr){
 	let handle = [];
 	handle.push(arr[0])
 	
  for(let i = 1;i < arr.length;i++){
    for(let j = handle.length-1;i>=0;i--){
      if(arr[i]>handle[j]){
        handle.splice(j+1,0,arr[i])
        break;
      }
      if(j === 0){
        handle.unshift(arr[i])
      }
    }
  }
  return handle;
}

insert(ary)
```

- 快排

```shell
function quick(arr){
 if(arr.length <=1){return arr;}
 let middleIndex = Math.floor(arr.length/2),
  		middleVal = arr.splice(middleIndex,1)[0],
  		leftarr = [],
  		rightarr = [];
 for(let i = 0;i <arr.length;i++){
   arr[i]>middleVal?rightarr.push(arr[i]):leftarr.push(arr[i])
 }
 return quick(leftarr).concat(middleVal,quick(rightarr))
}
```

##### 数组扁平化

- Flat

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

console.log(arr.flat(Infinity))
```

- toString

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

function fn(arr){
  return arr.toString().split(',').map((item)=>{
    return parseInt(item)
  })
}
```

- JSON.stringify

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

function fn(arr){
  return JSON.stringify(arr).replace(/\[|\]/ig,'').splt(',').map(item=>{
    return ParseInt(item)
  })
}
```

- `join('|')`

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

function fn(arr){
  return arr.join('|').split(/(?:,|\|)/ig).map(item=>{
    return parseInt(item)
  })
}
```

- 循环验证数组`[].concat(...arr)`

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

function flatten(arr){
  while(arr.some(item=>Array.isArray(item))){
    arr = flatten([].concat(...arr))			//[].concat(...arr)可以去掉一层
  }
  return arr;
}

```

- [review smileyqp]递归

```shell
let arr = [
    [1, 2, 2],
    [3, 4, 5, 5],
    [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

let result = []
function flatten(arr){
  for(let i = 0;i< arr.length;i++){
    let item = arr[i]
    if(Array.isArray(item)){
      item = flatten(item)
      continue;
    }
    result.push(item)
  }
  return result;
  
}

```

```shell
//直接挂载在数组原型上
(function(){
  function myflatten(){
  	let _result = [],
  			_this = this;
    let fn = (arr) => {
      for(let i = 0;i<arr.length;this++){
      	if(Array.isArray(arr[i])){
          fn(arr[i])
          continue;
      	}
      	result.push(arr[i])
      }
    }
    fn(_this)
    return result;
  }
  Array.prototype.myflatten = myflatten;
})()
```

##### 斐波那契数列

![](https://img-blog.csdnimg.cn/20210507233617893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjczMDU5,size_16,color_FFFFFF,t_70)

- 递归

```shell
function fn(n){
  if(n === 0|| n === 1){return 1;}
  return fn(n-2)+fn(n-1)
}
```

- 构造其他项

```shell
function fn(n){
  if(n<=0){return 1;}
  let arr = [1,1]
  let i = n+1-2;
  while(i>0){
    arr.push(arr[arr.length-1]+arr[arr.length-2])		//依次构造后一项，构造斐波那契数列
    i--;
  }
  return arr[arr.length-1]
}
```

- 递归

```shell
function fabonacci(count){
  fn(count,cur=1,next=1){
    if(count === 0){
      return 1
    }else{
      return fn(count-1,next,cur+next)		//把当前项当下一项
    }
  }
  fn(count)
}
```

##### 字节跳动经典算法题

- 输入一个正数N，输出所有和为N的连续正数序列
- 例如：输入15
- 结果：[[1,2,3,4,5],[4,5,6],[7,8]]

```shell
function fn(count){
  let result = [];
  let middle = Math.ceil(count/2)
  for(let i = 0;i <= middle;i++){
    for(let j = 2;;j++){		//j是几项相加，记的是项数
      let total = (i + (i+j-1))*j/2;
      if(total>count){
        break;
      }else if(total === count){
        result.push(createArr(i,j))
        break;
      }
    }
  }
  return result;
}

function createArr(n,len){
  let arr = new Array(len).fill(null)
  return arr.map((item,index)=>{
    return n+index
  })
}
```

























